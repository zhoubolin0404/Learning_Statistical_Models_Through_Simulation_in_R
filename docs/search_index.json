[["index.html", "学习统计模型——通过R模拟 概述 如何引用本书 发现问题？ 教育者需知", " 学习统计模型——通过R模拟 Zhou Bolin 2024-05-26 概述 本教材采用在R语言环境下模拟广义线性模型(General Linear Model, GLM)的方法来介绍统计分析。总体目标是教会学生如何将研究设计的描述转化为线性模型，来分析该研究的数据。重点是分析心理学实验数据所需的技能。 本教材包括以下内容： 线性模型工作流程; 方差-协方差矩阵; 多元回归; 交互作用(连续与分类; 分类与分类); 线性混合模型; 广义线性混合模型。 本课程的内容构成了格拉斯哥大学心理学院(University of Glasgow School of Psychology)由Dale Barr讲授的大学三年级一学期课程的基础。这也是由格拉斯哥大学心理学院工作人员开发的PsyTeachR系列课程材料的一部分。 与你可能遇到的其他教材不同，这是一本互动教材。每一章都包含嵌入式练习和网页应用来帮助学生更好地理解内容。你只有通过浏览器访问这些材料，这些互动内容才能正常工作。因此，不建议打印这些材料。如果你希望在没网的情况下访问教材或保存本地版本以防止网站变化或迁移，可以下载离线使用版本。只需要从ZIP压缩包中提取文件，在docs目录中找到index.html文件，然后使用浏览器打开这个文件即可。 如何引用本书 Barr, Dale J. (2021). Learning statistical models through simulation in R: An interactive textbook. Version 1.0.0. Retrieved from https://psyteachr.github.io/stat-models-v1. 发现问题？ 如果你发现错误或书写错误，有问题或建议，请在https://github.com/psyteachr/stat-models-v1/issues提交问题。谢谢！ 教育者需知 您可以根据自己的需求免费重复使用和修改本教材中的材料，但需要注明原作出处。请注意关于重复使用本材料的 Creative Commons CC-BY-SA 4.0 许可证的其他条款。 本书是使用R bookdown包构建的。源文件可在github上获得。 "],["前言.html", "1 前言 1.1 课程目的 1.2 广义线性混合模型(Generalized Linear Mixed-Effects Models, GLMMs) 1.3 关于可重复性的说明 1.4 基于模拟的方法", " 1 前言 1.1 课程目的 本课程的目的是教你如何分析(还有模拟!)作为心理学家你可能遇到的各种数据集。重点是行为数据——反应时、知觉判断、选择、决策、李克特量表评分、眼动、睡眠时间等。这些数据通常是在有计划的研究或实验中收集到的。 本课程旨在教授灵活、可推广、可重复的分析技术。你将学习到的技术是灵活的，这意味着它们可以应用到各式各样的研究设计和不同类型的数据上。通过充分考虑抽样对统计推断的潜在偏倚影响，它们在最大程度上具有可推广性——这有助于支持超越特定被试和实验中涉及的刺激得出结论。最后，你将学习到的技术会尽可能地做到可完全重复，因为你的分析将以R代码的纯文本脚本形式明确记录从原始数据到研究结果的每一个步骤。 1.2 广义线性混合模型(Generalized Linear Mixed-Effects Models, GLMMs) 本课程强调一个灵活的回归模型框架而不是教授处理不同类型数据的”公式”。课程假设你需要分析的基本数据类型将是多层的(multilevel)，而且你不仅仅需要处理连续测量数据，还要处理有序测量数据（李克特量表评分）、计数数据（特定事件发生的次数）以及名义数据（某物所属的类别）。 本课程结束时，你将学会如何使用广义线性混合模型(GLMMs)来量化因变量和一组预测变量之间的关系。要理解GLMMs，你需要学习以下三部分： “线性模型”部分，包括如何捕捉不同类型的预测变量及其交互作用； “混合”部分，包括如何使用随机效应来表示通过对同一批被试或刺激进行重复测量而产生的多层次依赖关系； “广义”部分，包括拓展线性模型来表示非完全正态自变量，包括计数、有序和二元变量。 1.2.1 线性模型 GLMMs是一般线性模型的扩展。一般线性模型是方差分析(ANOVA)、t检验和古典回归等更简单方法的基础。本课程的主要观点是：你可能遇到的几乎所有实验得到的数据都可以用GLMMs进行分析。 一个线性模型的简单例子： \\[Y_i = \\beta_0 + \\beta_1 X_i + e_i\\] 其中\\(Y_i\\)是样本\\(i\\)的因变量的观测值，由截距加上被系数\\(\\beta_1\\)加权的预测值\\(X_i\\)以及误差项构成。表示线性关系\\(Y_i = 3 + 2X_i + e_i\\)的模拟数据如图1.1所示。 图1.1: 线性模型Y = 3 + 2X的模拟数据 library(&quot;tidyverse&quot;) # if needed set.seed(62) dat &lt;- tibble(X = runif(100, -3, 3), Y = 3 + 2 * X + rnorm(100)) ggplot(dat, aes(X, Y)) + geom_point() + geom_abline(intercept = 3, slope = 2, color = &quot;blue&quot;) 你可能会发现上述方程表示的是一条直线(\\(y = mx + b\\))，其中\\(\\beta_0\\)是截距，\\(\\beta_1\\)是斜率。\\(e_i\\)是样本\\(i\\)的模型误差，表示样本观测值\\(Y_i\\)与给定\\(X_i\\)的模型预测值之间的差距。 表示法惯例 希腊字母(\\(\\beta\\), \\(\\rho\\), \\(\\tau\\))表示总体参数，通常是未观测到的，需要从数据中估计得到的。当我们想要区分估计参数和真实值时，我们会使用”hat”：如\\(\\hat{\\beta}_0\\)表示从数据中估计得到的\\(\\beta_0\\)的值。 大写拉丁字母(\\(X\\)、\\(Y\\))表示观测值——即你已经测量过的值，因此是已知的。你也会看到小写拉丁字母(如\\(e_i\\))，表示统计误差或其他我将称之为派生量或虚拟量的东西(这将在课程后面进行解释)。 线性模型中的”线性”并不像你想象的那样! 许多人认为”线性模型”只能捕捉线性关系，即可以用直线(或平面)来描述的关系。这是错误的。 线性模型是各种项的加权和，每个项都有一个预测变量(或常数)乘上一个系数。在上述模型中，系数是\\(\\beta_0\\)和\\(\\beta_1\\)。你可以用线性模型拟合各种复杂的关系，包括非线性关系，如下所示。 图1.2: 用线性模型建模的非线性关系 在左边面板中，我们使用线性模型\\(Y = \\beta_0 + \\beta_1 X + \\beta_2 X^2\\)捕捉了一个二次(抛物线)函数。X和Y之间的关系是非线性的，但模型本身是线性的。我们对预测变量\\(X\\)进行了平方处理，但系数\\(\\beta_0\\)、\\(\\beta_1\\)和\\(\\beta_2\\)并没有被平方、立方或类似的处理(它们都是”一次幂”)。 在中间面板中，我们使用线性模型捕捉了一个S形函数。在这里，Y变量表示某个事件的概率，例如基于学习时间来预测通过考试的概率。在这种情况下，我们通过在一个特殊的转换空间中估计线性模型来建模X和Y之间的关系，使得X-Y关系是线性的，然后将模型投影回非线性的概率空间(使用”链接函数”)。非线性来自于”链接函数”，但模型本身是线性的。 最后，右边面板展示了一种略显任意的波动模式，由广义可加混合模型捕获——这是一种我们在本课程中不会学到的高级技术。但从根本上说，它仍然是一个线性模型，因为它还是一系列复杂事物(在这种情况下是”基础函数”)的加权和，而系数提供了权重。 线性模型是一个系数是线性的模型；模型中的每个系数(\\(\\beta_0\\)、\\(\\beta_1\\))只允许被设置为一次幂，并且每个项\\(\\beta_i X_j\\)都只涉及单个系数。这些项只能与涉及其他系数的项相加，但不能相乘或相除(如\\(Y = \\frac{\\beta_1}{\\beta_2} X\\)是不允许的)。 当前课程的一个局限性是主要关注单变量数据，即将单一响应变量作为分析的焦点。通常情况下，你会处理相同对象的多个响应变量，但是同时对它们进行建模在技术上是非常困难的，并且超出了本课程的范围。一种更简单的方法(也是这里采用的方法)是对每个响应变量进行单独的单变量分析。 1.2.2 混合模型 研究结果的推断或解释的可推广性指的是它能够被轻松应用于超出特定研究背景(对象、刺激、任务等)的情境的程度。最理想的情况是，我们的发现能够适用于人类物种的所有成员，涵盖各种各样的刺激和任务；最糟糕的情况是，它们只能适用于那些受到我们使用的特定刺激的特定的人，在我们研究的特定背景下才观察得到。 研究结果的可推广性取决于几个因素：研究的设计方式、所使用的材料、被试的招募方式、给予被试的任务的性质以及数据分析的方式。在这门课程中我们将重点关注最后一点。在分析一个数据集时，如果你想要提出具有推广性的论断，你必须决定哪些可以算作你研究的重复——关于哪些方面应该在复制中保持不变，以及哪些方面允许变化。 不幸的是，有时你会发现数据以一种不太支持广泛意义上的可推广性的方式进行分析，这往往是因为低估了刺激材料或实验任务的独特特征对观测结果的影响 (Yarkoni, 2019)。 1.3 关于可重复性的说明 本课程的数据分析是使用R编写脚本进行的。 可重复性指的是在不同情况下重现研究结果的可能性程度。 如果我们能在给定原始数据的情况下得到相同的结果，我们会说这个发现在分析(analytically)或计算(computationally)上是可重复的。需要注意的是，这与说一个发现可复制(replicable)是不同的。可复制指的是能够在新样本中复制这一发现。对于这些术语并没有广泛的共识，但方便起见，我们可以将分析上的可重复性(reproducibility)和可复制性(replicability)视为两种不同但相关的可重复性(reproducibility)类型，前者反映分析员之间(或同一分析员随时间变化)的可重复性，而后者反映了在被试样本或亚群体之间的可重复性。 确保分析可重复性是一个难题。如果你未能正确记录自己的分析过程，或者你使用的软件被修改或过时并且变得不可用，你可能会在重现自己的发现时遇到麻烦！ 分析的另一个重要属性是透明度——在某种研究中所有步骤都可以公开的程度。一项研究可能是透明的但不可重复，反之亦然。使用促进透明度的工作流程非常重要。这使得脚本编程的“编辑–执行”工作流程对于数据分析来说是理想的选择，远远优于大多数商业统计软件的“点–点击”的工作流程。通过编写代码，你可以使逻辑和决策过程对他人明确，并易于重建。 1.4 基于模拟的方法 本课程最后一个重要特点是采用了基于模拟的方法来学习统计模型。通过数据模拟，我们定义一个特定模型来描述感兴趣的总体，然后利用计算机的随机数生成器来模拟从该总体中抽样的过程。我们将在下面看一个简单的例子。 在分析数据时，你会面临的经典问题是你不知道你正在研究的总体的“真实情况”。你从该总体中抽取一个样本，对观测到的数据获取方式做出一些假设，然后利用观察到的数据来估计未知的总体参数及这些参数的不确定性。 数据模拟颠倒了这个过程。你会定义一个模型的参数，代表关于(假设的)总体的真实情况，从中获取数据。然后，你可以像平常一样分析获得的数据，并考察参数估计与真实值之间的对应程度。 让我们看一个例子。假设你对以下问题感兴趣：作为学步幼儿的父母是否会“提高”你的反应能力。如果你曾经照顾过一个幼儿，你就会知道身体危险似乎总是在即——他们可能从刚刚爬上的椅子上摔下来，被门里夹到，头撞在桌子角上等等——所以你需要保持警惕并准备迅速行动。你假设这种警惕会转化为在幼儿不在场的其他情况下的更快反应时间，比如在心理实验室里。因此，你招募了一组有幼儿的父母来实验室。你让每个父母在闪烁的灯光出现时尽快按下按钮，并测量他们的反应时(以毫秒为单位)。对于每个父母，你计算了他们在所有试验中的平均反应时。我们可以使用R中的rnorm()函数模拟50个父母的平均反应时。但在我们开始之前，我们将加载我们需要的包（tidyverse）并设置随机种子(random seed)，以确保你(读者)得到和我(作者)相同的随机值。 library(&quot;tidyverse&quot;) set.seed(2021) # 可以是任意整数 parents &lt;- rnorm(n = 50, mean = 480, sd = 40) ## [1] 475.1016 502.0983 493.9460 494.3853 515.9221 403.0972 490.4698 516.6227 ## [9] 480.5509 549.1985 436.7118 469.0870 487.2798 540.3417 544.1788 406.3410 ## [17] 544.9324 485.2556 539.2449 540.5327 442.3023 472.5726 435.9550 528.3246 ## [25] 415.0025 484.2151 421.7823 465.8394 476.2520 524.0267 401.4470 422.0822 ## [33] 520.7777 423.1433 455.8187 416.6610 428.5627 421.8126 476.5172 500.1895 ## [41] 484.6555 550.4085 466.1953 564.8000 478.6249 448.3138 539.0206 450.9777 ## [49] 492.4952 507.6786 我们选择使用rnorm()来生成数据，这是一个从正态分布中生成随机数的函数，这反映了我们的假设——平均反应时在总体中呈正态分布。正态分布由两个参数定义，一个是均值(通常用希腊字母\\(\\mu\\)表示，发音为”myoo”)，另一个是标准差(通常用希腊字母\\(\\sigma\\)表示，发音为”sigma”)。由于我们自己生成了数据，所以\\(\\mu\\)和\\(\\sigma\\)都是已知的，在调用rnorm()时，我们将它们分别设置为480和40。 当然，为了验证我们的假设，我们需要一个对照组，所以我们定义了一个非父母的对照组。我们用相同的方式从这个对照组生成数据，但改变了平均值。 control &lt;- rnorm(n = 50, mean = 500, sd = 40) 让我们将它们放入数据框(tibble)中，以便更容易绘制和分析数据。该数据框中的每一行表示来自特定被试的平均反应时。 dat &lt;- tibble(group = rep(c(&quot;parent&quot;, &quot;control&quot;), each = 50), rt = c(parents, control)) dat ## # A tibble: 100 × 2 ## group rt ## &lt;chr&gt; &lt;dbl&gt; ## 1 parent 475. ## 2 parent 502. ## 3 parent 494. ## 4 parent 494. ## 5 parent 516. ## 6 parent 403. ## 7 parent 490. ## 8 parent 517. ## 9 parent 481. ## 10 parent 549. ## # ℹ 90 more rows 下面是对模拟数据的一些尝试。 以某种合理的方式绘制数据。 计算平均值和标准差。它们与总体参数相比如何? 对这些数据进行t检验。群组效应显著吗? 做完这些后，再做一次，但改变样本量、总体参数或两者都改变。 参考文献 Yarkoni, T. (2019). The generalizability crisis. https://doi.org/10.31234/osf.io/jqw35 "],["相关和回归.html", "2 相关和回归 2.1 相关矩阵(Correlation matrices) 2.2 模拟二元数据", " 2 相关和回归 2.1 相关矩阵(Correlation matrices) 你可能已经通过阅读心理学论文对相关矩阵这个概念有所了解。相关矩阵是总结同一个体的多个测量值之间关系的常用方法。 假设你用多个量表测量了心理幸福感。一个问题是这些量表在多大程度上测量了相同的东西。通常，你会查看相关矩阵来探索测量之间所有成对关系。 回忆一下，相关系数量化了两个变量之间关系的强度和方向。它通常用符号\\(r\\)或\\(\\rho\\)(希腊字母”rho”)表示。相关系数的范围在-1到1之间，其中0表示没有关系，正值反映正相关(一个变量增加，另一个也增加)，负值反映负相关(一个变量增加，另一个减少)。 图2.1: 不同类型的二元关系 如果你有\\(n\\)个测量值，你可以计算多少个成对相关？你可以用下面蓝框中的公式来计算，也可以更简单地通过R中的choose(n, 2)函数直接计算。例如，要获得6个测量值之间可能的成对相关数量，你可以输入choose(6, 2)，这会告诉你有15对组合。 对于任意\\(n\\)个测量值，你可以计算\\(\\frac{n!}{2(n - 2)!}\\)个各值之间的成对相关。符号\\(!\\)称为阶乘(factorial)运算符，定义为从1到\\(n\\)所有数字的乘积。因此，如果你有6个测量值，你可以得到 \\[ \\frac{6!}{2(6-2)!} = \\frac{1 \\times 2 \\times 3 \\times 4 \\times 5 \\times 6}{2\\left(1 \\times 2 \\times 3 \\times 4\\right)} = \\frac{720}{2(24)} = 15 \\] 你可以使用R中的base::cor()或corrr::correlate()来创建相关矩阵。我们更喜欢后者函数，因为cor()要求你的数据存储在矩阵中，而我们将处理的大多数数据是存储在数据框中的表格数据。corrr::correlate()函数将数据框作为第一个参数，并提供”整洁”的输出，因此它可以更好地与tidyverse系列函数和管道操作符(%&gt;%)联动。 让我们创建一个相关矩阵来看看它是如何工作的。首先加载我们需要的包。 library(&quot;tidyverse&quot;) library(&quot;corrr&quot;) # 如缺失(missing)，在控制台(console)中输入install.packages(&quot;corrr&quot;) 我们将使用starwars数据集，这是在加载tidyverse包后可用的内置数据集。该数据集包含了出现在星球大战电影系列中的各种角色的信息。让我们来看看之间的相关性 starwars %&gt;% select(height, mass, birth_year) %&gt;% correlate() ## Correlation computed with ## • Method: &#39;pearson&#39; ## • Missing treated using: &#39;pairwise.complete.obs&#39; ## # A tibble: 3 × 4 ## term height mass birth_year ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 height NA 0.131 -0.404 ## 2 mass 0.131 NA 0.478 ## 3 birth_year -0.404 0.478 NA 你可以在任意给定的行或列的交叉处查找任何双变量相关系数。因此，height和mass之间的相关系数是.131，你可以在第1行，第2列或第2行，第1列找到它——它们是相同的。请注意，这里只有choose(3, 2) = 3个唯一的双变量关系，但每个关系在表中出现了两次。我们可能只想显示唯一的组合，这可以通过在管道中附加corrr::shave()来实现。 starwars %&gt;% select(height, mass, birth_year) %&gt;% correlate() %&gt;% shave() ## Correlation computed with ## • Method: &#39;pearson&#39; ## • Missing treated using: &#39;pairwise.complete.obs&#39; ## # A tibble: 3 × 4 ## term height mass birth_year ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 height NA NA NA ## 2 mass 0.131 NA NA ## 3 birth_year -0.404 0.478 NA 现在我们只有相关矩阵的下三角部分，但NA看起来很难看，前导0也不美观。corrr包还提供了fashion()函数，可以对其进行清理(更多选项请查阅?corrr::fashion)。 starwars %&gt;% select(height, mass, birth_year) %&gt;% correlate() %&gt;% shave() %&gt;% fashion() ## Correlation computed with ## • Method: &#39;pearson&#39; ## • Missing treated using: &#39;pairwise.complete.obs&#39; ## term height mass birth_year ## 1 height ## 2 mass .13 ## 3 birth_year -.40 .48 相关性只有在关系(大致)线性且没有严重的异常值对结果产生过大影响时才能很好地描述关系。因此，可视化相关性通常和量化它们一样是个好主意。base::pairs()函数可以实现这一点。pairs()的第一个参数形式为~ v1 + v2 + v3 + ... + vn，其中v1、v2等是你想要进行相关分析的变量名。 pairs(~ height + mass + birth_year, starwars) 图2.2: 星球大战数据集相关关系 我们会发现一个巨大的离群值影响了我们的数据。具体来说是有个体重超过1200kg的生物。让我们找出它并从数据集里面删掉它。 starwars %&gt;% filter(mass &gt; 1200) %&gt;% select(name, mass, height, birth_year) ## # A tibble: 1 × 4 ## name mass height birth_year ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Jabba Desilijic Tiure 1358 175 600 好了，让我们看看没有了这个庞然大物的数据会是什么样子。 starwars2 &lt;- starwars %&gt;% filter(name != &quot;Jabba Desilijic Tiure&quot;) pairs(~height + mass + birth_year, starwars2) 图2.3: 去除体重离群值后星球大战数据集相关关系 好多了，但还有个生物的离群出生年份可能是我们不想要的。 starwars2 %&gt;% filter(birth_year &gt; 800) %&gt;% select(name, height, mass, birth_year) ## # A tibble: 1 × 4 ## name height mass birth_year ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Yoda 66 17 896 是尤达大师！他和宇宙一样古老。让我们抛开他看看图会怎么样。 starwars3 &lt;- starwars2 %&gt;% filter(name != &quot;Yoda&quot;) pairs(~height + mass + birth_year, starwars3) 图2.4: 去除体重和出生年份离群值后星球大战数据集相关关系 看起来更好了。让我们看看它是怎样改变我们的相关矩阵的。 starwars3 %&gt;% select(height, mass, birth_year) %&gt;% correlate() %&gt;% shave() %&gt;% fashion() ## Correlation computed with ## • Method: &#39;pearson&#39; ## • Missing treated using: &#39;pairwise.complete.obs&#39; ## term height mass birth_year ## 1 height ## 2 mass .73 ## 3 birth_year .44 .24 请注意，这些值与我们开始时的值有很大不同。 有时移除离群值不是一个好办法。处理离群值的另一个办法是使用一种更稳健(robust)的方法。使用corrr::correlate()默认计算的相关系数是Pearson积差相关(Pearson product-moment correlation)系数。我们也能通过改变correlate()的method()参数来计算Spearman相关系数。这将在计算相关性之前用排名替换原始值，因此仍会包括离群值，但影响将大大减小。 starwars %&gt;% select(height, mass, birth_year) %&gt;% correlate(method = &quot;spearman&quot;) %&gt;% shave() %&gt;% fashion() ## Correlation computed with ## • Method: &#39;spearman&#39; ## • Missing treated using: &#39;pairwise.complete.obs&#39; ## term height mass birth_year ## 1 height ## 2 mass .72 ## 3 birth_year .15 .15 顺便一提，如果你用R Markdown生成报告，并希望你的表格有个好看的格式，可以使用knitr:: able()。 starwars %&gt;% select(height, mass, birth_year) %&gt;% correlate(method = &quot;spearman&quot;) %&gt;% shave() %&gt;% fashion() %&gt;% knitr::kable() term height mass birth_year height mass .72 birth_year .15 .15 2.2 模拟二元数据 你已经学会了使用rnorm()函数从正态分布中模拟数据。回忆一下，rnorm()允许你指定单个变量的平均值和标准差。那我们怎么模拟相关变量呢？ 应该很明确，你不能仅仅运行两次rnorm()后组合变量就完事。因为这会得到两个不相关的变量，即相关性为零。 MASS包提供mvrnorm()函数，这是rnorm的”多元”(multivariate)版(因此函数的名字是’mv’ + ‘rnorm’，这样更容易记住)。 提示 R预装了MASS包。但MASS包中你唯一可能会用到的函数只是mvrnorm()，因此相比于使用library(\"MASS\")加载包，使用MASS::mvrnorm()是更好的办法，尤其是在MASS和tidyverse里的dplyr包不太合得来的情况下(因为两个包都有select()函数)。因此，如果在加载tidyverse之后加载MASS，那么最终得到的select()是MASS版本，而不是dplyr版本。这会让你绞尽脑汁来找出代码的问题所在，所以总在不加载的情况下使用MASS::mvrnorm()吧。 这里作者贴了一则他在Twitter(现X)上吐槽MASS的打油诗，不过现在已经查不到了QwQ，考虑到翻译水平不佳，附上原文！ MASS before dplyr, clashes not dire; dplyr before MASS, pain in the ass. —— Dale Barr(September 30, 2014) 请查看mvrnorm()函数的文档(在控制台输入?MASS::mvrnorm)。 有3个参数需要注意： 参数 描述 n 所需样本数 mu 一个给出变量均值的向量 Sigma 一个正定对称矩阵，用于指定变量的协方差矩阵 对n和mu的描述可以理解，但“一个正定对称矩阵(positive-definite symmetric matrix)，用于指定变量的协方差矩阵”是什么意思？ "],["参考文献.html", "参考文献", " 参考文献 Yarkoni, T. (2019). The generalizability crisis. https://doi.org/10.31234/osf.io/jqw35 "]]
